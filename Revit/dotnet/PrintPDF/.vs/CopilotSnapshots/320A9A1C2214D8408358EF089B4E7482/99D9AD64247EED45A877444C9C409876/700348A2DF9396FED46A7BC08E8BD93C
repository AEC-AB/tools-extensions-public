using System.Diagnostics.CodeAnalysis;
using System.Text.RegularExpressions;
using System.Linq;
using System.IO;
using PrintPDF.Enums;
using PrintPDF.Helpers;

namespace PrintPDF;

public class PrintPDFWorker
{
    private readonly Document _document;
    private readonly PrintPDFArgs _args;
    private readonly PDFExportOptions _pdfOptions;
    private readonly SimpleLogger _logger;
    private readonly Telemetry _telemetry;

    public PrintPDFWorker(Document document, PrintPDFArgs args, SimpleLogger logger, Telemetry telemetry)
    {
        _document = document;
        _args = args;
        _logger = logger;
        _telemetry = telemetry;
        _pdfOptions = CreatePdfOptions();
    }

    // ordering is selected by callers depending on context
    internal void PrintPDF(List<ViewSheet> sheets, string sheetSetName = "", OrderingTechnique ordering = OrderingTechnique.Alphanumeric)
    {
        var folderName = _args.DestinationDirectory ?? string.Empty;
        // Decide ordering technique. The enum is chosen by callers.
        switch (ordering)
        {
            case OrderingTechnique.PreserveSourceOrder:
                // keep the order as supplied by the caller
                break;
            case OrderingTechnique.Alphanumeric:
            default:
                sheets = OrderingHelper.GetOrderedSheets(sheets);
                break;
        }
        _telemetry?.IncrementSheetsRequested(sheets.Count);
        _logger.Info($"PrintPDF called with {sheets.Count} sheets. Combine={_args.Combine}");
        _logger.Info($"PrintPDF called with {sheets.Count} sheets. Combine={_args.Combine}");

        // If there are no sheets to export, nothing to do.
        if (sheets == null || !sheets.Any())
        {
            _logger?.Info("No sheets to export - skipping PDF creation.");
            return;
        }

        // Create destination folder only when we know there are PDFs to create. Do this before calling
        // Revit's Export so the folder exists.
        try
        {
            if (!string.IsNullOrEmpty(folderName) && !Directory.Exists(folderName))
                Directory.CreateDirectory(folderName);
        }
        catch (Exception ex)
        {
            _logger.Error($"Failed to create destination directory '{folderName}': {ex.Message}");
            _telemetry?.IncrementErrors();
            // Continue - Revit export may still succeed if path is accessible, but log the problem.
        }

        if (_args.Combine)
        {
            ExportCombined(sheets, sheetSetName, folderName);
            return;
        }

        foreach (var sheet in sheets)
        {
            ExportSingleSheet(sheet, folderName);
        }
    }

    private void ExportCombined(List<ViewSheet> sheets, string sheetSetName, string folderName)
    {
        Transaction? tx = null;
        try
        {
            if (sheets != null && sheets.Any(SheetNeedsTemporaryRename))
            {
                tx = new Transaction(_document, "PrintPDF - temporary sheet rename (combined)");
                tx.Start();
                PrintPDFFailurePreprocessor.Attach(tx);

                foreach (var s in sheets)
                {
                    if (SheetNeedsTemporaryRename(s))
                        TemporarilySanitizeSheetForExport(s);
                }
            }

            var exportViewIds = sheets.Select(x => x.Id).ToList();
            var fileName = ResolveCombinedFileName(sheetSetName);

            // Ensure we have a sanitized filename and a .pdf extension. Revit may ignore provided names,
            // but when it does honor them we should try to use a safe filename.
            var sanitizedFileName = ExportFileHelpers.SanitizeFileName(fileName);
            if (!sanitizedFileName.EndsWith(".pdf", StringComparison.OrdinalIgnoreCase))
                sanitizedFileName += ".pdf";

            _pdfOptions.FileName = sanitizedFileName;

            DeleteExistingFileIfPresent(folderName, sanitizedFileName);

            _logger.Info($"SheetSet: {sheetSetName}");
            _logger.Info($"Exporting combined PDF '{_pdfOptions.FileName}' to '{folderName}' with {exportViewIds.Count} pages.");

            _telemetry?.MarkCombinedExport();

            // Call export. Some Revit versions ignore the filename; after export attempt to locate the
            // generated PDF in the destination folder. If found and the name differs, try to move/rename it
            // to the requested name to keep behavior consistent.

            if (_args.OpenViewOnExport)
            {
                var uiDoc = new UIDocument(_document);
                var currentView = uiDoc.ActiveView;
                var currentViewId = currentView?.Id;
                try
                {
                    foreach (var viewId in exportViewIds)
                    {
                        var view = _document.GetElement(viewId) as View;
                        uiDoc.ActiveView = view;
                        try
                        {
                            _document.Export(folderName, [viewId], _pdfOptions);
                        }
                        finally
                        {
                            // Close the view after export to minimize open views, but don't close the original view
                            if (viewId.ToString() != currentViewId?.ToString())
                            {
                                var openView = uiDoc.GetOpenUIViews().FirstOrDefault(x => x.ViewId == viewId);
                                openView?.Close();
                            }
                        }
                    }
                }
                finally
                {
                    // Restore the original view to leave the UI in the state we found it
                    if (currentView != null)
                        uiDoc.ActiveView = currentView;
                }
            }
            else
            {
                _document.Export(folderName, exportViewIds, _pdfOptions);            
            }
    

            try
            {
                var generated = ExportFileHelpers.FindGeneratedPdfForNameOrRecent(folderName, sheetSetName);
                var expectedFullPath = Path.Combine(folderName ?? string.Empty, sanitizedFileName);

                if (string.IsNullOrEmpty(generated) || !File.Exists(generated))
                {
                    _logger.Error($"Could not locate generated combined PDF after export to '{folderName}'. Expected '{expectedFullPath}'");
                    _telemetry?.IncrementErrors();
                    return;
                }

                if (string.Equals(generated, expectedFullPath, StringComparison.OrdinalIgnoreCase))
                {
                    _logger.Info($"Combined PDF generated at expected path '{expectedFullPath}'.");
                    return;
                }

                var moved = ExportFileHelpers.MoveOrCopyFileSafely(generated, expectedFullPath);
                if (moved)
                {
                    _logger.Info($"Moved/Copied generated combined PDF '{generated}' to '{expectedFullPath}'");
                    return;
                }

                _logger.Error($"Failed to move or copy generated combined PDF '{generated}' to '{expectedFullPath}'");
                _telemetry?.IncrementErrors();
            }
            catch (Exception ex)
            {
                _logger.Error($"Error while locating or moving generated combined PDF: {ex.Message}");
                _telemetry?.IncrementErrors();
            }
        }
        finally
        {
            if (tx != null && tx.GetStatus() == TransactionStatus.Started)
                tx.RollBack();
        }
    }

    // Return the final filename to use for the combined PDF following the configured priority.
    private string ResolveCombinedFileName(string sheetSetName)
    {
        if (_args.UseSheetSetNameAsPdfName && !string.IsNullOrEmpty(sheetSetName))
        {
            // When using a sheetset/viewset/collection name as the PDF name, also apply any
            // configured prefix/suffix so the final filename is consistent with single-sheet
            // exports which already apply prefix/suffix in CreatePdfName.
            var fileName = sheetSetName;
            if (!string.IsNullOrEmpty(_args.PrefixFileName))
                fileName = _args.PrefixFileName + fileName;
            if (!string.IsNullOrEmpty(_args.SuffixFileName))
                fileName += _args.SuffixFileName;

            return fileName;
        }

        if (!string.IsNullOrEmpty(_args.CombinedFileName))
            return _args.CombinedFileName!;

        return _pdfOptions.FileName;
    }

    // Delete an existing file in the destination folder that would conflict with the export.
    private void DeleteExistingFileIfPresent(string folderName, string fileName)
    {
        var folder = folderName ?? string.Empty;
        var existingPath = Path.Combine(folder, fileName);
        try
        {
            if (File.Exists(existingPath))
                File.Delete(existingPath);
        }
        catch (Exception ex)
        {
            // Log failure to delete, but don't throw; export should still be attempted.
            _logger.Error($"Failed to delete existing combined PDF '{existingPath}': {ex.Message}");
            _telemetry?.IncrementErrors();
        }
    }

    private void ExportSingleSheet(ViewSheet sheet, string folderName)
    {
        var exportViewIds = new List<ElementId> { sheet.Id };

        Transaction? tx = null;
        try
        {
            if (SheetNeedsTemporaryRename(sheet))
            {
                tx = new Transaction(_document, "PrintPDF - temporary sheet rename");
                tx.Start();
                PrintPDFFailurePreprocessor.Attach(tx);

                TemporarilySanitizeSheetForExport(sheet);
            }

            var tempFullPath = GetTempFullPathForSheet(sheet, folderName);
            DeleteFileIfExists(tempFullPath);

            // Ask Revit to export the single sheet.
            _document.Export(folderName, exportViewIds, _pdfOptions);

            var generatedFile = ResolveGeneratedFileForSheet(folderName, sheet.Name, tempFullPath);

            var finalPath = ComputeFinalSheetFilePath(folderName, sheet);
            DeleteFileIfExists(finalPath);

            MoveOrCopyGeneratedFile(generatedFile, finalPath, sheet.Name);
        }
        finally
        {
            // Always rollback so we don't leave the model modified.
            if (tx != null && tx.GetStatus() == TransactionStatus.Started)
                tx.RollBack();
        }
    }

    private static bool SheetNeedsTemporaryRename(ViewSheet sheet)
    {
        // Revit export can fail if the underlying naming rule uses name/number with invalid filename chars.
        // Only start a transaction when it's necessary.
        return ExportFileHelpers.ContainsInvalidFileNameChars(sheet.Name) ||
               ExportFileHelpers.ContainsInvalidFileNameChars(sheet.SheetNumber);
    }

    private void TemporarilySanitizeSheetForExport(ViewSheet sheet)
    {
        // Keep the change minimal: just replace invalid filename characters.
        // If the sanitized value is empty, use a stable fallback.
        var safeName = ExportFileHelpers.SanitizeFileName(sheet.Name);
        if (string.IsNullOrWhiteSpace(safeName))
            safeName = "Sheet";

        var safeNumber = ExportFileHelpers.SanitizeFileName(sheet.SheetNumber);
        if (string.IsNullOrWhiteSpace(safeNumber))
            safeNumber = "0";

        // Setting these may throw if uniqueness rules are violated; let it bubble to caller.
        sheet.Name = safeName;
        sheet.SheetNumber = safeNumber;
    }

    private static string GetTempFullPathForSheet(ViewSheet sheet, string folderName)
    {
        var tempFileName = ExportFileHelpers.CreateTempFileNameForSheet(sheet);
        return string.IsNullOrEmpty(folderName) ? tempFileName : Path.Combine(folderName, tempFileName);
    }   

    private static void DeleteFileIfExists(string path)
    {
        try
        {
            if (!string.IsNullOrEmpty(path) && File.Exists(path))
                File.Delete(path);
        }
        catch
        {
            // best-effort delete; callers will log or increment telemetry if needed
        }
    }

    private static string ResolveGeneratedFileForSheet(string folderName, string sheetName, string tempFullPath)
    {
        try
        {
            string generatedFile = ExportFileHelpers.FindGeneratedPdfForSheet(folderName, sheetName);
            if (string.IsNullOrEmpty(generatedFile) || !File.Exists(generatedFile))
                return tempFullPath;
            return generatedFile;
        }
        catch
        {
            return tempFullPath;
        }
    }

    private string ComputeFinalSheetFilePath(string folderName, ViewSheet sheet)
    {
        var fileName = CreatePdfName(sheet) + ".pdf";
        return Path.Combine(folderName ?? string.Empty, fileName);
    }

    private void MoveOrCopyGeneratedFile(string generatedFile, string newFileName, string sheetName)
    {
        try
        {
            if (string.IsNullOrEmpty(generatedFile) || !File.Exists(generatedFile))
            {
                _logger.Error($"Generated file for sheet '{sheetName}' not found. Expected '{generatedFile}'");
                _telemetry?.IncrementErrors();
                return;
            }

            var moved = ExportFileHelpers.MoveOrCopyFileSafely(generatedFile, newFileName);
            if (moved)
            {
                _logger.Info($"Moved/Copied generated file '{generatedFile}' to '{newFileName}'");
                _telemetry?.IncrementSheetsExported();
                _telemetry?.AddExportedSheetName(sheetName);
            }
            else
            {
                _logger.Error($"Failed to move or copy generated file '{generatedFile}' to '{newFileName}'");
                _telemetry?.IncrementErrors();
            }
        }
        catch (Exception ex)
        {
            _logger.Error($"Unexpected error while moving/copying generated file '{generatedFile}' to '{newFileName}': {ex.Message}");
            _telemetry?.IncrementErrors();
        }
    }

    private string CreatePdfName(ViewSheet sheet)
    {
        string fileName;
        var docName = sheet.Document.Title;
        var separator = _args.SeparatorInFileName;
        switch (_args.NamingOptions)
        {
            case NamingOptions.SheetNameOnly:
                fileName = sheet.Name;
                break;
            case NamingOptions.SheetNumberOnly:
                fileName = sheet.SheetNumber;
                break;
            case NamingOptions.SheetNameAndNumber:
                fileName = sheet.Name + separator + sheet.SheetNumber;
                break;
            case NamingOptions.SheetNumberAndName:
                fileName = sheet.SheetNumber + separator + sheet.Name;
                break;
            case NamingOptions.ProjectNameAndSheetNameAndNumber:
                fileName = $"{docName}{separator}{sheet.Name}{separator}{sheet.SheetNumber}";
                break;
            case NamingOptions.ProjectNameAndSheetName:
                fileName = $"{docName}{separator}{sheet.Name}";
                break;
            case NamingOptions.ProjectNameAndSheetNumber:
                fileName = $"{docName}{separator}{sheet.SheetNumber}";
                break;
            case NamingOptions.SheetNameAndNumberAndProjectName:
                fileName = $"{sheet.Name}{separator}{sheet.SheetNumber}{separator}{docName}";
                break;
            case NamingOptions.SheetNameAndProjectName:
                fileName = $"{sheet.Name}{separator}{docName}";
                break;
            case NamingOptions.SheetNumberAndProjectName:
                fileName = $"{sheet.SheetNumber}{separator}{docName}";
                break;
            case NamingOptions.CustomNamingConvention:
                var customFileName = _args.CustomNamingConvention;
                if (string.IsNullOrEmpty(customFileName))
                {
                    fileName = sheet.Name;
                    break;
                }
                customFileName = customFileName!.Replace("{SheetName}", sheet.Name);
                customFileName = customFileName.Replace("{SheetNumber}", sheet.SheetNumber);
                customFileName = customFileName.Replace("{ProjectName}", docName);
                if (customFileName.Contains("{"))
                    customFileName = ExportFileHelpers.ReplaceRevitParameterVariables(customFileName, sheet);

                fileName = customFileName;
                fileName = Regex.Replace(fileName, @"[<>:""/\\|?*]", "_");
                return fileName;
            default:
                fileName = sheet.SheetNumber;
                break;
        }

        if (!string.IsNullOrEmpty(_args.PrefixFileName))
            fileName = _args.PrefixFileName + fileName;

        if (!string.IsNullOrEmpty(_args.SuffixFileName))
            fileName += _args.SuffixFileName;

        fileName = Regex.Replace(fileName, @"[<>:""/\\|?*]", "_");

        return fileName;
    }

    // Revit parameter replacement moved to ExportFileHelpers.ReplaceRevitParameterVariables

    private PDFExportOptions CreatePdfOptions()
    {
        return new PDFExportOptions
        {
            AlwaysUseRaster = _args.AlwaysUseRaster,
            ColorDepth = _args.ColorDepthType,
            Combine = _args.Combine,
            ExportQuality = _args.PDFExportQualityType,
            FileName = $"PdfCombined_{DateTime.Now:D}",
            HideCropBoundaries = _args.HideCropBoundaries,
            HideReferencePlane = _args.HideReferencePlane,
            HideScopeBoxes = _args.HideScopeBoxes,
            HideUnreferencedViewTags = _args.HideUnreferencedViewTags,
            MaskCoincidentLines = _args.MaskCoincidentLines,
            OriginOffsetX = _args.OriginOffsetX,
            OriginOffsetY = _args.OriginOffsetY,
            PaperFormat = _args.ExportPaperFormat,
            PaperOrientation = _args.PageOrientationType,
            PaperPlacement = _args.PaperPlacementType,
            RasterQuality = _args.RasterQualityType,
            ReplaceHalftoneWithThinLines = _args.ReplaceHalftoneWithThinLines,
            StopOnError = true,
            ViewLinksInBlue = _args.ViewLinksInBlue,
            ZoomPercentage = _args.ZoomPercentage,
            ZoomType = _args.ZoomType
        };
    }

    // SanitizeFileName moved to ExportFileHelpers.SanitizeFileName

    // FindGeneratedPdfForSheet moved to ExportFileHelpers.FindGeneratedPdfForSheet

    // Export order logging was switched to use SimpleLogger (in-memory) instead of creating files on disk.
}
