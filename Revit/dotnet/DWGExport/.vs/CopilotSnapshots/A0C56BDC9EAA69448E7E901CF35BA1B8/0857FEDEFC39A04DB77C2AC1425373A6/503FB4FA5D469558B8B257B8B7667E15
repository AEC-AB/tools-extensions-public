using System.Text.RegularExpressions;

namespace DWGExport
{
    public class DWGExportCommand : IRevitExtension<DWGExportArgs>
    {
        private DWGExportArgs? _args;
        private int _exportedCount = 0;
        private int _failedCount = 0;

        public IExtensionResult Run(IRevitExtensionContext context, DWGExportArgs args, CancellationToken cancellationToken)
        {
            // cache args locally and guard against nulls as early as possible
            _args = args ?? throw new ArgumentNullException(nameof(args));

            var document = context?.UIApplication?.ActiveUIDocument?.Document;
            if (document == null)
                return Result.Text.Failed("No active Revit document.");

            if (!OptionalFunctionalityUtils.IsDWGExportAvailable())
                return Result.Text.Failed("DWG Exporter missing. Please install it and try again!");

            if (string.IsNullOrWhiteSpace(_args.DestinationDirectory))
                return Result.Text.Failed("Destination directory is required.");

            if (cancellationToken.IsCancellationRequested)
                return Result.Text.Failed($"Operation cancelled. Exported: {_exportedCount}, Failed: {_failedCount}");

            try
            {
                // Ensure destination directory exists and is writable
                if (!System.IO.Directory.Exists(_args.DestinationDirectory))
                {
                    try
                    {
                        System.IO.Directory.CreateDirectory(_args.DestinationDirectory!);
                    }
                    catch (Exception ex)
                    {
                        return Result.Text.Failed($"Failed to access destination directory: {ex.Message}.");
                    }
                }

                var dwgOptions = CreateDWGOptions();
#if R2022_OR_LESS
                var notLegendFilter = new ElementParameterFilter(ParameterFilterRuleFactory.CreateEqualsRule(new ElementId(BuiltInParameter.VIEW_TYPE_SCHEDULES), "Legend", true), true);
#else
                var notLegendFilter = new ElementParameterFilter(ParameterFilterRuleFactory.CreateEqualsRule(new ElementId(BuiltInParameter.VIEW_TYPE_SCHEDULES), "Legend"), true);
#endif
                using var collector = new FilteredElementCollector(document)
                    .WherePasses(notLegendFilter)
                    .WhereElementIsNotElementType();

                switch (_args.ExportOption)
                {
                    case ExportOptions.ActiveView:
                    {
                        var activeView = document.ActiveView;
                        if (activeView == null || !activeView.CanBePrinted)
                            return Result.Text.Failed("Active view cannot be printed.");

                        if (activeView.ViewType == ViewType.DrawingSheet)
                            ExportDrawingSheet(document, dwgOptions, activeView, cancellationToken);
                        else
                            ExportView(document, dwgOptions, activeView, cancellationToken);
                        break;
                    }
                    case ExportOptions.AllViews:
                    {
                        var viewColl = collector.OfClass(typeof(View)).GetElementIterator();
                        while (viewColl.MoveNext())
                        {
                            if (cancellationToken.IsCancellationRequested)
                                return Result.Text.Failed($"Operation cancelled. Exported: {_exportedCount}, Failed: {_failedCount}");

                            var view = viewColl.Current as View;
                            if (view == null || !view.CanBePrinted || view.ViewType == ViewType.DrawingSheet)
                                continue;

                            ExportView(document, dwgOptions, view, cancellationToken);
                        }
                        break;
                    }
                    case ExportOptions.AllSheets:
                    {
                        var sheetColl = collector.OfClass(typeof(ViewSheet)).GetElementIterator();
                        while (sheetColl.MoveNext())
                        {
                            if (cancellationToken.IsCancellationRequested)
                                return Result.Text.Failed($"Operation cancelled. Exported: {_exportedCount}, Failed: {_failedCount}");

                            var viewSheet = sheetColl.Current as ViewSheet;
                            if (viewSheet == null || !viewSheet.CanBePrinted)
                                continue;

                            ExportDrawingSheet(document, dwgOptions, viewSheet, cancellationToken);
                        }
                        break;
                    }
                    case ExportOptions.CustomFilter:
                    {
                        if (_args.CustomFilter == null)
                            return Result.Text.Failed("Custom filter is null.");

                        var views = _args.CustomFilter.GetElementIterator();
                        while (views.MoveNext())
                        {
                            if (cancellationToken.IsCancellationRequested)
                                return Result.Text.Failed($"Operation cancelled. Exported: {_exportedCount}, Failed: {_failedCount}");

                            var view = views.Current as View;
                            if (view == null || !view.CanBePrinted)
                                continue;

                            if (view.ViewType == ViewType.DrawingSheet)
                                ExportDrawingSheet(document, dwgOptions, view, cancellationToken);
                            else
                                ExportView(document, dwgOptions, view, cancellationToken);
                        }
                        break;
                    }
                    case ExportOptions.ViewSet:
                    {
                        var viewSet = new FilteredElementCollector(document)
                            .OfClass(typeof(ViewSheetSet))
                            .OfType<ViewSheetSet>()
                            .FirstOrDefault(x => x.Name == _args.ViewSet);

                        if (viewSet == null)
                            return Result.Text.Failed("View set not found.");

                        foreach (View view in viewSet.Views)
                        {
                            if (cancellationToken.IsCancellationRequested)
                                return Result.Text.Failed($"Operation cancelled. Exported: {_exportedCount}, Failed: {_failedCount}");

                            if (view == null || !view.CanBePrinted)
                                continue;

                            if (view.ViewType == ViewType.DrawingSheet)
                                ExportDrawingSheet(document, dwgOptions, view, cancellationToken);
                            else
                                ExportView(document, dwgOptions, view, cancellationToken);
                        }
                        break;
                    }
                    case ExportOptions.UseRegexInViewSet:
                    {
                        var regex = _args.RegexPattern;
                        if (string.IsNullOrWhiteSpace(regex))
                            return Result.Text.Failed("Regex pattern is empty.");

                        if (!IsRegexValid(regex))
                            return Result.Text.Failed("Invalid Regex pattern.");

                        var allViewSets = new FilteredElementCollector(document)
                            .OfClass(typeof(ViewSheetSet))
                            .GetElementIterator();

                        while (allViewSets.MoveNext())
                        {
                            if (cancellationToken.IsCancellationRequested)
                                return Result.Text.Failed($"Operation cancelled. Exported: {_exportedCount}, Failed: {_failedCount}");

                            if (allViewSets.Current is not ViewSheetSet viewSetRegex)
                                continue;

                            if (!Regex.IsMatch(viewSetRegex.Name, regex))
                                continue;

                            foreach (View view in viewSetRegex.Views)
                            {
                                if (cancellationToken.IsCancellationRequested)
                                    return Result.Text.Failed($"Operation cancelled. Exported: {_exportedCount}, Failed: {_failedCount}");

                                if (view == null || !view.CanBePrinted)
                                    continue;

                                if (view.ViewType == ViewType.DrawingSheet)
                                    ExportDrawingSheet(document, dwgOptions, view, cancellationToken);
                                else
                                    ExportView(document, dwgOptions, view, cancellationToken);
                            }
                        }

                        if (_exportedCount == 0)
                            return Result.Text.Failed("No view set matches the regex pattern.");

                        break;
                    }
                    default:
                        throw new ArgumentOutOfRangeException(nameof(_args.ExportOption), _args.ExportOption, "Unsupported export option.");
                }

                if (_exportedCount == 0)
                    return Result.Text.Failed("No views or sheets were exported.");

                return Result.Text.Succeeded($"Export completed. Exported: {_exportedCount}, Failed: {_failedCount}");
            }
            catch (OperationCanceledException)
            {
                return Result.Text.Failed($"Operation cancelled. Exported: {_exportedCount}, Failed: {_failedCount}");
            }
            catch (Exception exception)
            {
                // surface both message and minimal context but avoid leaking full stack in user-facing UI
                return Result.Text.Failed($"Unhandled error during DWG export: {exception.Message}");
            }
        }

        private static bool IsRegexValid(string pattern)
        {
            if (string.IsNullOrWhiteSpace(pattern))
                return false;

            try
            {
                _ = Regex.Match(string.Empty, pattern);
                return true;
            }
            catch (ArgumentException)
            {
                return false;
            }
        }

        private void ExportView(Document doc, DWGExportOptions dwgOptions, View view, CancellationToken cancellationToken)
        {
            if (cancellationToken.IsCancellationRequested)
                throw new OperationCanceledException(cancellationToken);

            try
            {
                var expViews = new List<ElementId> { view.Id };
                var viewName = GetDwgName(view);
                var success = doc.Export(_args!.DestinationDirectory, viewName, expViews, dwgOptions);
                if (success)
                    _exportedCount++;
                else
                    _failedCount++;
            }
            catch
            {
                _failedCount++;
                throw;
            }
        }

        private void ExportDrawingSheet(Document doc, DWGExportOptions dwgOptions, View view, CancellationToken cancellationToken)
        {
            if (cancellationToken.IsCancellationRequested)
                throw new OperationCanceledException(cancellationToken);

            try
            {
                var expViews = new List<ElementId> { view.Id };
                var viewName = GetDwgName(view);
                var success = doc.Export(_args!.DestinationDirectory, viewName, expViews, dwgOptions);
                if (success)
                    _exportedCount++;
                else
                    _failedCount++;
            }
            catch
            {
                _failedCount++;
                throw;
            }
        }

        private DWGExportOptions CreateDWGOptions()
        {
            if (_args == null)
                throw new InvalidOperationException("Export options cannot be created before arguments are initialized.");

            return new DWGExportOptions
            {
                ACAPreference = _args.ACAPreference,
                Colors = _args.Colors,
                ExportingAreas = _args.ExportingAreas,
                ExportOfSolids = _args.ExportOfSolids,
                FileVersion = _args.FileVersion,
                //HatchBackgroundColor = _args.HatchBackgroundColor,
                //HatchPatternsFileName = _args.HatchPatternsFileName,
                HideReferencePlane = _args.HideReferencePlane,
                HideScopeBox = _args.HideScopeBox,
                HideUnreferenceViewTags = _args.HideUnreferenceViewTags,
                //LayerMapping = _args.LayerMapping,
                //LineScaling = _args.LineScaling,
                //LinetypesFileName = _args.LinetypesFileName,
                MarkNonplotLayers = false,
                MergedViews = _args.MergedViews,
                //NonplotSuffix = _args.NonplotSuffix,
                PreserveCoincidentLines = _args.PreserveCoincidentLines,
                PropOverrides = _args.PropOverrideMode,
                SharedCoords = _args.SharedCoords,
                TargetUnit = _args.Values,
                //TextTreatment = _args.TextTreatment,
                //UseHatchBackgroundColor = _args.UseHatchBackgroundColor
            };
        }

        private string GetDwgName(View view)
        {
            if (_args == null)
                throw new InvalidOperationException("Arguments must be initialized before generating DWG names.");

            string fileName;
            var fullPath = FullPath(view.Document);
            var docName = System.IO.Path.GetFileNameWithoutExtension(fullPath);
            var separator = _args.SeparatorInFileName;

            switch (_args.NamingOptions)
            {
                case NamingOptions.ViewNameOnly:
                    fileName = view.Name;
                    break;
                case NamingOptions.ModelNameOnly:
                    fileName = docName;
                    break;
                case NamingOptions.ModelNameAndViewName:
                    fileName = $"{docName}{separator}{view.Name}";
                    break;
                case NamingOptions.ViewNameAndModelName:
                    fileName = $"{view.Name}{separator}{docName}";
                    break;
                case NamingOptions.Custom:
                    var customFileName = _args.CustomNamingConvention;
                    if (string.IsNullOrWhiteSpace(customFileName))
                    {
                        fileName = view.Name;
                        break;
                    }

                    customFileName = customFileName.Replace("{ViewName}", view.Name);
                    customFileName = customFileName.Replace("{ModelName}", docName);

                    if (customFileName.Contains("{"))
                        customFileName = ReplaceRevitParameterVariables(customFileName, view);

                    fileName = customFileName;
                    break;
                default:
                    fileName = view.Name;
                    break;
            }

            if (!string.IsNullOrEmpty(_args.PrefixFileName))
                fileName = _args.PrefixFileName + fileName;

            if (!string.IsNullOrEmpty(_args.SuffixFileName))
                fileName += _args.SuffixFileName;

            // replace characters that are invalid in Windows file names
            fileName = Regex.Replace(fileName, "[<>:\"/\\|?*]", "_");

            return fileName;
        }

        private static string ReplaceRevitParameterVariables(string customFileName, View view)
        {
            var parameters = view.Parameters;
            foreach (Parameter param in parameters)
            {
                var paramValue = param.AsValueString();
                if (string.IsNullOrEmpty(paramValue))
                    continue;

                var paramName = param.Definition.Name;
                customFileName = customFileName.Replace("{" + paramName + "}", paramValue);
            }
            return customFileName;
        }

        public static string FullPath(Document document)
        {
            if (document.IsLinked || !document.IsWorkshared)
                return document.PathName;

            var modelPath = document.GetWorksharingCentralModelPath();
            var path = ModelPathUtils.ConvertModelPathToUserVisiblePath(modelPath);
            return string.IsNullOrEmpty(path) ? document.PathName : path;
        }
    }
}